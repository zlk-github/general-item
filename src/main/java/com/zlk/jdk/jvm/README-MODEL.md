## JVM内存区域分布


### 1 JVM内存区域分布

下图为java7 内存模型

![Image text](./images/JAVA7.png)

下图为java8 内存模型

![Image text](./images/JAVA8.png)

    JAVA8相较于JAVA7，去除了方法区（永久代）。
        方法区中的静态变量、字符串常量池等移到堆内存中。
        原方法区中存储的类信息、编译后的代码数据等已经移动到了元空间（MetaSpace）中，元空间并没有处于堆内存上，而是直接占用的本地内存。元空间的大小仅受本地内存限制，但可以通过-XX:MetaspaceSize和-XX:MaxMetaspaceSize来指定元空间的大小。
    去除永久代原因： 永久代GC困难，容易出现内存溢出与性能问题。

Java8的JVM内存模型包括，堆、栈（java虚拟机栈与本地方法栈）、程序计数器以及元空间。

**线程共享区域**：

    元空间（使用本地内存）：类信息（类版本号、方法、接口）;（其中元空间是以前JAVA7方法区的部分实现）
    堆：存放对象实例（对象与数组），静态区（常量、静态变量）。

**线程隔离区域**：

    程序计数器：执行字节码的执行指示器;
    虚拟机栈：针对Java方法，存储局部变量、操作数、动态链接（对象引用地址）、方法出口等;
    本地方法栈：针对本地方法存储局部变量、操作数、动态链接（本地对象引用地址）、本地方法出口等）。

### 2 JVM内存模型介绍

#### 2.1 程序计数器

作用：

    程序计数器是一个较小的内存空间，他可以看作是当前线程执行字节码的执行指示器。
    线程是一个独立的执行单元，由cpu控制。
    字节码解释器工作时通过改变计数器的值来选取下一条执行字节码的指令。分支、循环、跳转、异常处理、线程恢复都依赖于程序计数器。
特点：（线程隔离）

    线程间程序计数器独立不影响，每个线程会有自己的程序计数器来记录执行。程序计数器是JAVA中唯一没有OutOfMemorError的区域，由JVM自己维护。

总结：
    
    程序计数器用于记录线程执行字节码对应行号，并通过改变计数器的值获取下一条执行指令。
    程序计数器是线程隔离的，是JAVA中唯一没有OutOfMemorError的区域，由JVM自己维护。

#### 2.2 虚拟机栈

作用：（针对Java方法）

    每一个方法执行的同时会创建一个栈帧用于存储局部变量、操作数、动态链接（对象引用地址）、方法出口等。每个方法从调用到执行完成，就对应栈帧的入栈与出栈。（先进后出）

特点：（线程隔离）

    线程间虚拟机栈独立不影响。
    当请求入栈深度大于JVM虚拟机栈深度，会产生栈溢出StackOverflowError(SOE)。通俗来讲就是当前线程调用方法数量大过了虚拟机栈的最大值，导致不能添加从而栈溢出。

总结：

    虚拟机栈是用于控制方法的执行顺序（方法先进后出，方法的调用与执行完成分别对应入栈与出栈），每一个方法执行的同时Java虚拟机栈会创建一个栈帧用于存储局部变量、动态链接（对象引用地址）、操作数与方法出口等。
    虚拟机栈是线程隔离的，会产生栈溢出StackOverflowError(SOE)。

#### 2.2 虚拟机栈

作用：（针对Java方法）

    每一个方法执行的同时会创建一个栈帧用于存储局部变量、操作数、动态链接（对象引用地址）、方法出口等。每个方法从调用到执行完成，就对应栈帧的入栈与出栈。（先进后出）

特点：（线程隔离）

    线程间虚拟机栈独立不影响。
    当请求入栈深度大于JVM虚拟机栈深度，会产生栈溢出StackOverflowError(SOE)。通俗来讲就是当前线程调用方法数量大过了虚拟机栈的最大值，导致不能添加从而栈溢出。

总结：

    虚拟机栈是用于控制方法的执行顺序（方法先进后出，方法的调用与执行完成分别对应入栈与出栈），每一个方法执行的同时Java虚拟机栈会创建一个栈帧用于存储局部变量、动态链接（对象引用地址）、操作数与方法出口等。
    虚拟机栈是线程隔离的，会产生栈溢出StackOverflowError(SOE)。

#### 2.3 本地方法栈

作用：（针对本地方法，native修饰）

    每一个native方法执行的同时会创建一个栈帧用于存储局部变量、操作数、动态链接（对象引用地址）、方法出口等。每个方法从调用到执行完成，就对应栈帧的入栈与出栈。（先进后出）

特点：（线程隔离）

    线程间本地方法栈独立不影响。
    当请求入栈深度大于JVM本地方法栈深度，会产生栈溢出StackOverflowError(SOE)。通俗来讲就是当前线程调用方法数量大过了本地方法栈的最大值，导致不能添加从而栈溢出。
    Hotshot将虚拟机栈与本地方法栈合而唯一了，别的厂商则是分开的。

总结：

    本地方法栈是用于控制native方法的执行顺序（方法先进后出，方法的调用与执行完成分别对应入栈与出栈），每一个方法执行的同时本地方法栈会创建一个栈帧用于存储局部变量、动态链接（对象引用地址）、操作数与方法出口等。
    本地方法栈是线程隔离的，会产生栈溢出StackOverflowError(SOE)。
    Hotshot将虚拟机栈与本地方法栈合而唯一了，别的厂商则是分开的。

#### 2.4 堆

作用：

    堆是一块用来存放对象实例（对象与数组）的内存区域，占内存较大，垃圾回收就针对该区域。

特点：（线程共享）

    线程间堆信息共享。
    堆分为新生代（To Space,From Space,Eden）与老年代。
    当对象实例需要的内存大于JVM堆的剩余最大内存，会产生内存泄漏OutOfMemoryError(OME)。

总结：

    堆是一块用来存放对象实例（对象与数组）的内存区域，静态区（常量、静态变量），占内存较大，垃圾回收就针对该区域。
    堆是线程共享的，会产生内存泄漏OutOfMemoryError(OOM)。
    堆分为新生代（To Space,From Space,Eden）与老年代。
注：

    配置：
    -Xmx 最大堆内存
    -Xms 最小堆内存
    -Xmn 年轻代内存；如-Xms10 M
    查看堆信息
    sudo  jmap  -heap 端口号
    jmap 信息包含。。。。。。

#### 2.5 元空间

作用：

    元空间（使用本地内存）：类信息（类版本号、方法、接口），即时编译后的代码等数据。（其中元空间是以前JAVA7方法区的部分实现）

特点：（线程共享）

    线程间元空间信息共享。
    会产生内存泄漏OutOfMemoryError(OOM)。

总结：

    元空间是用来存储已被Java虚拟机加载的类信息（类版本号、方法、接口）、即时编译后的代码等数据。
    方法区是线程共享的（使用本地内存）。

注：

    运行时常量池：运行时常量池在元空间。
    Class文件常量池(静态常量池)：
    字符串常量池（String）：字符串常量池还在堆。